<script>
  document.getElementById("y").textContent = new Date().getFullYear();

  const maxFreeRuns = 5;
  let freeRuns = parseInt(localStorage.getItem("raidFreeRuns") || "0", 10);
  const usageCounter = document.getElementById("usageCounter");
  const modal = document.getElementById("paywallModal");

  function updateCounter() {
    const remaining = Math.max(0, maxFreeRuns - freeRuns);
    usageCounter.textContent = remaining > 0 
      ? `ðŸ†“ You have ${remaining} free run${remaining !== 1 ? "s" : ""} left`
      : "ðŸš€ Free limit reached â€” Upgrade to Pro";
  }
  updateCounter();

  document.querySelectorAll(".pro-only").forEach(btn => {
    btn.addEventListener("click", e => { e.preventDefault(); modal.style.display = "flex"; });
  });
  document.getElementById("closeModal").onclick = () => modal.style.display = "none";

  // ðŸ”¹ Cleaner export formatting
  function cleanLine(line) {
    return line
      .replace(/\b(gonna|gotta|um|uh|so|like|yeah)\b/gi, "") // remove filler words
      .replace(/\d{1,2}:\d{2}/g, "")                        // strip timestamps
      .replace(/\s+/g, " ")                                 // collapse spaces
      .trim();
  }

  function formatRAID(categories, conf) {
    let out = `Confidence: ${conf}%\n\n`;
    for (const [key, arr] of Object.entries(categories)) {
      out += `${key}:\n`;
      out += arr.length 
        ? arr.map(l => "  â€¢ " + cleanLine(l)).join("\n") 
        : "  â€¢ None";
      out += "\n\n";
    }
    return out.trim();
  }

  function extractRAID() {
    if (freeRuns >= maxFreeRuns) { modal.style.display = "flex"; return; }
    freeRuns++; localStorage.setItem("raidFreeRuns", freeRuns); updateCounter();

    const text = document.getElementById("input").value;
    const output = document.getElementById("output");
    if (!text.trim()) { 
      output.innerHTML = "<p style='color:var(--muted)'>Paste or upload a transcript.</p>"; 
      document.getElementById("conf-score").textContent = "0%"; 
      return; 
    }

    const cats = { Risks:[], Actions:[], Issues:[], Decisions:[] };
    const lines = text.split(/\r?\n/);
    lines.forEach(l => {
      if (/risk/i.test(l)) cats.Risks.push(l);
      else if (/action/i.test(l)) cats.Actions.push(l);
      else if (/issue/i.test(l)) cats.Issues.push(l);
      else if (/decision/i.test(l)) cats.Decisions.push(l);
    });

    const tagged = Object.values(cats).reduce((a,b)=>a+b.length,0);
   const nonEmpty = lines.filter(l => l.trim().length > 0).length;
const conf = Math.round((tagged / (nonEmpty || 1)) * 100);
    const scoreEl = document.getElementById("conf-score");
    scoreEl.textContent = isNaN(conf) ? "0%" : conf+"%";
    scoreEl.style.color = conf>=70?"limegreen":conf>=40?"orange":"red";

    // ðŸ”¹ Build clean HTML output
    let html=""; 
    for (const [k,v] of Object.entries(cats)) {
      html += `<div class="toggle" onclick="this.nextElementSibling.classList.toggle('hidden')">${k} (${v.length})</div><ul>`;
      html += v.length 
        ? v.map(l => `<li>${cleanLine(l)}</li>`).join("") 
        : `<li><em>No ${k.toLowerCase()} found.</em></li>`;
      html += "</ul>";
    }
    output.innerHTML = html;

    // Copy + CSV export use cleaned text
    document.getElementById("copy").onclick = async () => { 
      await navigator.clipboard.writeText(formatRAID(cats,conf)); 
      alert("ðŸ“‹ Copied!"); 
    };
    document.getElementById("download").onclick = () => {
      let csv="Category,Text\n"; 
      for (const [k,arr] of Object.entries(cats)) {
        arr.forEach(l => csv+=`"${k}","${cleanLine(l).replace(/"/g,'""')}"\n`);
      }
      const blob=new Blob([csv],{type:"text/csv"}); 
      const a=document.createElement("a"); 
      a.href=URL.createObjectURL(blob); 
      a.download="raid.csv"; 
      a.click();
    };
  }

  // File handling remains unchanged
  document.getElementById("fileInput").addEventListener("change", async (e) => {
    const f=e.target.files[0]; if(!f) return;
    if(f.name.endsWith(".txt")){
      document.getElementById("input").value=await f.text(); extractRAID();
    }
    else if(f.name.endsWith(".docx")){
      const r=new FileReader(); 
      r.onload=async(ev)=>{
        const res=await mammoth.extractRawText({arrayBuffer:ev.target.result}); 
        document.getElementById("input").value=res.value; extractRAID();
      }; 
      r.readAsArrayBuffer(f);
    }
    else if(f.name.endsWith(".pdf")){
      const r=new FileReader(); 
      r.onload=async(ev)=>{
        const arr=new Uint8Array(ev.target.result); 
        const pdf=await pdfjsLib.getDocument(arr).promise; 
        let t=""; 
        for(let i=1;i<=pdf.numPages;i++){
          const p=await pdf.getPage(i); 
          const txt=await p.getTextContent(); 
          t+=txt.items.map(s=>s.str).join(" ")+"\\n";
        } 
        document.getElementById("input").value=t; extractRAID();
      }; 
      r.readAsArrayBuffer(f);
    }
  });

  document.getElementById("run").onclick = extractRAID;
  document.getElementById("clear").onclick = () => { 
    document.getElementById("input").value=""; 
    document.getElementById("output").innerHTML=""; 
    document.getElementById("conf-score").textContent="0%"; 
  };
</script>
